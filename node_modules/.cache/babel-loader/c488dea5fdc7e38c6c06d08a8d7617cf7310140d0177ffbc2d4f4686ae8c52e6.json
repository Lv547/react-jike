{"ast":null,"code":"// axios的封装处理\nimport axios from\"axios\";import{getToken,removeToken}from\"./token\";import router from\"@/router\";// 1. 根域名配置\n// 2. 超时时间\n// 3. 请求拦截器 / 响应拦截器\nvar request=axios.create({baseURL:'http://geek.itheima.net/v1_0',timeout:5000});// 添加请求拦截器\n// 在请求发送之前 做拦截 插入一些自定义的配置 [参数的处理]\nrequest.interceptors.request.use(function(config){// 操作这个config 注入token数据\n// 1. 获取到token\n// 2. 按照后端的格式要求做token拼接\nvar token=getToken();if(token){config.headers.Authorization=\"Bearer \".concat(token);}return config;},function(error){return Promise.reject(error);});// 添加响应拦截器\n// 在响应返回到客户端之前 做拦截 重点处理返回的数据\nrequest.interceptors.response.use(function(response){// 2xx 范围内的状态码都会触发该函数。\n// 对响应数据做点什么\nreturn response.data;},function(error){// 超出 2xx 范围的状态码都会触发该函数。\n// 对响应错误做点什么\n// 监控401 token失效\nconsole.dir(error);if(error.response.status===401){removeToken();router.navigate('/login');window.location.reload();}return Promise.reject(error);});export{request};","map":{"version":3,"names":["axios","getToken","removeToken","router","request","create","baseURL","timeout","interceptors","use","config","token","headers","Authorization","concat","error","Promise","reject","response","data","console","dir","status","navigate","window","location","reload"],"sources":["D:/BaiduNetdiskDownload/React 基础 - 配套资料/React 基础 - 配套资料/React 基础 - day09/03-code/react-jike/src/utils/request.js"],"sourcesContent":["// axios的封装处理\nimport axios from \"axios\"\nimport { getToken, removeToken } from \"./token\"\nimport router from \"@/router\"\n// 1. 根域名配置\n// 2. 超时时间\n// 3. 请求拦截器 / 响应拦截器\n\nconst request = axios.create({\n  baseURL: 'http://geek.itheima.net/v1_0',\n  timeout: 5000\n})\n\n// 添加请求拦截器\n// 在请求发送之前 做拦截 插入一些自定义的配置 [参数的处理]\nrequest.interceptors.request.use((config) => {\n  // 操作这个config 注入token数据\n  // 1. 获取到token\n  // 2. 按照后端的格式要求做token拼接\n  const token = getToken()\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`\n  }\n  return config\n}, (error) => {\n  return Promise.reject(error)\n})\n\n// 添加响应拦截器\n// 在响应返回到客户端之前 做拦截 重点处理返回的数据\nrequest.interceptors.response.use((response) => {\n  // 2xx 范围内的状态码都会触发该函数。\n  // 对响应数据做点什么\n  return response.data\n}, (error) => {\n  // 超出 2xx 范围的状态码都会触发该函数。\n  // 对响应错误做点什么\n  // 监控401 token失效\n  console.dir(error)\n  if (error.response.status === 401) {\n    removeToken()\n    router.navigate('/login')\n    window.location.reload()\n  }\n  return Promise.reject(error)\n})\n\nexport { request }\n\n\n\n"],"mappings":"AAAA;AACA,MAAO,CAAAA,KAAK,KAAM,OAAO,CACzB,OAASC,QAAQ,CAAEC,WAAW,KAAQ,SAAS,CAC/C,MAAO,CAAAC,MAAM,KAAM,UAAU,CAC7B;AACA;AACA;AAEA,GAAM,CAAAC,OAAO,CAAGJ,KAAK,CAACK,MAAM,CAAC,CAC3BC,OAAO,CAAE,8BAA8B,CACvCC,OAAO,CAAE,IACX,CAAC,CAAC,CAEF;AACA;AACAH,OAAO,CAACI,YAAY,CAACJ,OAAO,CAACK,GAAG,CAAC,SAACC,MAAM,CAAK,CAC3C;AACA;AACA;AACA,GAAM,CAAAC,KAAK,CAAGV,QAAQ,CAAC,CAAC,CACxB,GAAIU,KAAK,CAAE,CACTD,MAAM,CAACE,OAAO,CAACC,aAAa,WAAAC,MAAA,CAAaH,KAAK,CAAE,CAClD,CACA,MAAO,CAAAD,MAAM,CACf,CAAC,CAAE,SAACK,KAAK,CAAK,CACZ,MAAO,CAAAC,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC,CAC9B,CAAC,CAAC,CAEF;AACA;AACAX,OAAO,CAACI,YAAY,CAACU,QAAQ,CAACT,GAAG,CAAC,SAACS,QAAQ,CAAK,CAC9C;AACA;AACA,MAAO,CAAAA,QAAQ,CAACC,IAAI,CACtB,CAAC,CAAE,SAACJ,KAAK,CAAK,CACZ;AACA;AACA;AACAK,OAAO,CAACC,GAAG,CAACN,KAAK,CAAC,CAClB,GAAIA,KAAK,CAACG,QAAQ,CAACI,MAAM,GAAK,GAAG,CAAE,CACjCpB,WAAW,CAAC,CAAC,CACbC,MAAM,CAACoB,QAAQ,CAAC,QAAQ,CAAC,CACzBC,MAAM,CAACC,QAAQ,CAACC,MAAM,CAAC,CAAC,CAC1B,CACA,MAAO,CAAAV,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC,CAC9B,CAAC,CAAC,CAEF,OAASX,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}